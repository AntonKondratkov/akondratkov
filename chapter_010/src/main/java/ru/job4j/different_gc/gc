1. Используя разные ключи запуска виртуальной машины установить различные виды сборщика мусора.

Для экспериментов я использовал четыре сборщика мусора:

1. Serial (последовательный) — самый простой вариант для приложений с небольшим объемом данных и
не требовательных к задержкам. Редко когда используется, но на слабых компьютерах может быть
выбран виртуальной машиной в качестве сборщика по умолчанию.
Использование Serial GC включается опцией -XX:+UseSerialGC

2. Parallel (параллельный) — наследует подходы к сборке от последовательного сборщика, но добавляет
параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые
параметры производительности.
Параллельный сборщик включается опцией -XX:+UseParallelGC

3. Concurrent Mark Sweep (CMS) — нацелен на снижение максимальных задержек путем выполнения части работ
по сборке мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими
объемами данных в памяти.
Использование CMS GC включается опцией -XX:+UseConcMarkSweepGC

4. Garbage-First (G1) — создан для постепенной замены CMS, особенно в серверных приложениях, работающих
на многопроцессорных серверах и оперирующих большими объемами данных.
G1 включается опцией Java -XX:+UseG1GC


2. Оценить поведения срабатывания различных типов сборщиков мусора для программы из первого урока данного модуля.

1. Serial - срабатывает несколько раз передзапуском цикла for. Также можно увидеть, что сборщик начинает работу во время выполнения цикла for, соответственно приостанавливая работу всего приложения.

[0.010s][info][gc] Using Serial
[0.119s][info][gc] GC(0) Pause Young (Allocation Failure) 1M->0M(3M) 1.937ms
[0.165s][info][gc] GC(1) Pause Young (Allocation Failure) 1M->0M(3M) 1.869ms
[0.169s][info][gc] GC(2) Pause Young (Allocation Failure) 1M->0M(3M) 0.810ms
[0.203s][info][gc] GC(3) Pause Young (Allocation Failure) 2M->1M(3M) 1.681ms

Сообщение Allocation Failure означает, что в процессе очистки памяти в куче не остается свободных регионов, в которые можно было бы копировать выжившие объекты. В таком случае сборщик выполняет полную сборку мусора по всей куче при остановленных основных потоках приложения.

2. Parallel - запускается гораздо чаще последовательного сборщика мусора, ввиду того что сборка мусора происходит во множестве потоков, а не в одном, что также уменьшает время очистки от мусора. Также как и последовательный сборщик, запускается во время выполнения цикла for приостанавливая работу приложения.

[0.011s][info][gc] Using Parallel
[0.081s][info][gc] GC(0) Pause Young (Allocation Failure) 0M->0M(3M) 0.934ms
[0.118s][info][gc] GC(1) Pause Young (Allocation Failure) 0M->0M(3M) 0.853ms
[0.150s][info][gc] GC(2) Pause Young (Allocation Failure) 1M->0M(3M) 0.984ms
[0.155s][info][gc] GC(3) Pause Young (Allocation Failure) 1M->0M(3M) 1.261ms
[0.157s][info][gc] GC(4) Pause Young (Allocation Failure) 1M->0M(3M) 1.158ms
[0.158s][info][gc] GC(5) Pause Young (Allocation Failure) 1M->1M(3M) 0.859ms
[0.164s][info][gc] GC(6) Pause Young (Allocation Failure) 1M->1M(3M) 0.792ms
[0.185s][info][gc] GC(7) Pause Young (Allocation Failure) 1M->1M(3M) 1.036ms
[0.203s][info][gc] GC(8) Pause Young (Allocation Failure) 2M->1M(3M) 0.893ms


3. Concurrent Mark Sweep (CMS)
При использовании данного сборщика мусора, помимо остановок приложения для малой сборки мусора (Pause Young) как у предыдущих двух сборщиков присутствует ещё две фазы при которых приложение останавливается.
 - Pause Initial Mark. Во время этой остановки сборщик мусора помечает все объекты напрямую доступные из корней. После этого приложение запускается и сборщик параллельно с работой приложения начинает поиск объектов по ссылкам из помеченных ранее корневых объектов.
 - Pause Remark. Фаза дополнения набора живых объектов при старшей сборке (Pause Initial Mark).

[0.017s][info   ][gc] Using Concurrent Mark Sweep
[0.157s][info   ][gc] GC(0) Pause Young (Allocation Failure) 1M->0M(3M) 4.211ms
[0.211s][info   ][gc] GC(1) Pause Young (Allocation Failure) 1M->0M(3M) 1.895ms
[0.217s][info   ][gc] GC(2) Pause Young (Allocation Failure) 1M->1M(3M) 0.910ms
[0.294s][info   ][gc] GC(3) Pause Young (Allocation Failure) 2M->1M(3M) 1.493ms
[0.301s][info   ][gc] GC(4) Pause Initial Mark 1M->1M(3M) 5.685ms
[0.301s][info   ][gc] GC(4) Concurrent Mark

.................................

[0.365s][info   ][gc] GC(4) Concurrent Mark 64.155ms
[0.365s][info   ][gc] GC(4) Concurrent Preclean
[0.365s][info   ][gc] GC(4) Concurrent Preclean 0.198ms
[0.368s][info   ][gc] GC(4) Pause Remark 2M->2M(3M) 2.235ms
[0.368s][info   ][gc] GC(4) Concurrent Sweep
[0.368s][info   ][gc] GC(4) Concurrent Sweep 0.556ms
[0.368s][info   ][gc] GC(4) Concurrent Reset
[0.368s][info   ][gc] GC(4) Concurrent Reset 0.019ms


Как видно из лога, сборщик мусора старается разделять по времени малые и старшие сборки мусора, чтобы не создавать больших пауз в работе приложения.
Следует отметить, что Concurrent алгоритмы (mark, preclean, sweep, reset) не вызывают остановку приложения, т.е. сборка мусора работает параллельно приложению.

4. Garbage-First (G1)
Работа данного сборщика визуально похожа на работу Concurrent Mark Sweep. Видимое отличие заключается в том, что
появляется дополнительная фаза, при которой приостанавливается работа приложения - Cleanup. В данной фазе происходит очистка вспомогательных структур учета ссылок на объекты и поиск пустых регионов, которые уже можно использовать для размещения новых объектов.

[0.011s][info   ][gc] Using G1
[0.146s][info   ][gc] GC(0) Pause Young (Normal) (G1 Evacuation Pause) 1M->0M(4M) 1.700ms
[0.186s][info   ][gc] GC(1) Pause Young (Normal) (G1 Evacuation Pause) 1M->1M(4M) 1.902ms
[0.188s][info   ][gc] GC(2) Pause Young (Normal) (G1 Evacuation Pause) 1M->1M(4M) 0.688ms
[0.219s][info   ][gc] GC(3) Pause Young (Normal) (G1 Evacuation Pause) 2M->1M(4M) 1.825ms

.................................

[0.525s][info][gc] GC(14) Pause Cleanup 2M->2M(4M) 0.020ms
[0.526s][info][gc] GC(14) Concurrent Cycle 4.691ms

3. Как вы считаете какой из сборщиков мусора подойдет наиболее оптимально для приложения заявок из второго модуля?

Для приложения заявок из второго модуля оптимальным будет последовательный сборщик мусора, так как приложение небольшое.

4. Какой тип сборщика будет оптимален для серверного приложения?

Для серверного приложения (серверный вариант приложения заявок из второго модуля) оптимальным будет параллельный сборщик мусора, так как приложение хоть и серверное, но всё же оперирует небольшим объёмом информации.