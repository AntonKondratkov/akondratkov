Анализ работы программы заявок (tracker) проводился для операции  добавления множества заявок в хранилище и
вывода добавленных заявок в консоль.

public static void main(String[] args) {
        Tracker tracker = new Tracker();
        for (int i = 0; i < 100000000; i++) {
            System.out.println(tracker.add(new Item("name - " + i, "description - " + i)));
        }
    }

Формат вывода заявок в консоль был следующий:

Имя заявки: name - 9885362, Описание заявки: description - 9885362 id заявки: 1584581982398
Имя заявки: name - 9885363, Описание заявки: description - 9885363 id заявки: 1581508296591
Имя заявки: name - 9885364, Описание заявки: description - 9885364 id заявки: 1584886393274
Имя заявки: name - 9885365, Описание заявки: description - 9885365 id заявки: 1585535173101
Имя заявки: name - 9885366, Описание заявки: description - 9885366 id заявки: 1582961996596

Анализ проводил для последовательного сборщика мусора.

Из графика загруженности памяти видно, что используемая память в куче постепенно, но пилообразно росла.
График получился пилообразным, т.к. в процессе работы программы включался сборщик мусора и подчищал память от мусора.
Далее, когда используемая память приблизилась к максимальной, работа приложения сильно затормозилась в виду того,
что сборщик начал чаще включаться в работу, при это работал более продолжительно, стараясь не допустить переполнения
памяти (OutOfMemoryError).
В момент переполнения памяти возникла ошибка java.lang.OutOfMemoryError: Java heap space и
график загрузки памяти пошёл на спад. Также интересно, что, даже не смотря на работу сборщика мусора, график
используемой памяти растёт вверх. Это может говорить о том, что в программе происходит утечка памяти.
По графику работы процессора видны всплески в моменты, когда в работу включался сборщик мусора.
Максимальная загрузка процессора составляла не более 25%, что говорит о том, что последовательный сборщик мусора
не требователен к ресурсам.
