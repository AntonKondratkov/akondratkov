2. Создать объект User и руками рассчитать сколько он будет занимать памяти.

Расчет будет производится для 64-х разрядной системы.

Создадим объект User user = new User("Name").

Заголовок у этого объекта равен 16 байтам.

Так как этот класс имеет одно поле типа String, необходимо рассчитать и его размер.

Рассчитаем для new String("Name").

Класс String имеет следующие поля:
private final char value[];
private final int offset;
private final int count;
private int hash;

Здесь:
Заголовок - 16 байт,
Поля типа int - 3 x 4 байта = 12 байт,
Ссылочная переменная на объект массива - 4 байта
Итого: 32

Плюс массив new char[4]
Здесь:
Заголовок - 16 байт + 4 байта (значение длины массива) = 20 байт,
Примитивы char - 4 символа x 2 байта = 8 байт,
Выравнивание кратности 8 - 4 байта
Итого: 32

Итого значение размера одного объекта User - 16 байт + 64 байта = 80 байт.

<----------------------------------------------------------------------------------------------------->

3. Нужно найти информацию. Сколько памяти занимает пустой объект без полей.

У пустого объекта нет никакой информации кроме заголовока.
И в зависимости от разрядности используемой JVM будет меняться и размер этого заголовка.

JVM 32 bit - 8 байт
JVM 64 bit - 12 байт + 4 байта (для выравнивания кратности 8) = 16 байт

Стоит также отметить, что в java размер любого объекта кратен 8 байтам.

<----------------------------------------------------------------------------------------------------->

4. Добиться состояния, когда виртуальная машины вызывает сборщик мусора самостоятельно. За счет ключей xmx.
5. Объяснить поведение программы в текстовом файле.

public static void main(String[] args) {
        User user = new User("Name");
        System.out.println(user);
        user = null;
        System.gc();
    }
}

Здесь я создал объект класса User, произвел с ним действие (вывел в консоль), затем
присвоил переменной user значение null и искусственнно вызывал сборщик мусора с помощью метода System.gc().
В консоль вывелась следующая информация:

User{name='Name'}
finalize

В данном примере сборщик мусора запустился, прошёл сверху вниз по коду и посмотрел существуют ли
ссылки на объекты. Дошёл до строки user = null, увидел что на объект new User("Name") отсутствует ссылка
и вызвал метод finalize.
Но воообще, при вызове метода System.gc() не гарантируется запуск сборщика мусора в тот же момент.
В данном примере программа небольшая и занимает мало памяти соответственно сборщику мусора нет нужды
запускаться и очищать память от неиспользуемых объектов в момент вызова System.gc().

Теперь попробуем создать ситуацию, чтобы Garbage Collection постоянно вызывался без искусственного
вызова (через System.gc). Для этого необходимо создать объект и посчитать, сколько места он будет занимать
в памяти. Далее через параметр Xmx можно указать виртуальной машине сколько памяти она может использовать.

Значение параметра Xmx сделаем 4 Мб или 1 048 576‬ байт.

Один объект User занимает в памяти 80 байт.

Делим значение параметра Xmx на количество памяти, которое занимает один объект User:
1 048 576‬ байт / 80 байт = 13 107 объектов типа User.

Следовательно мы можем смело создавать 13 107 объектов типа User, выделенной памяти виртуальной машины должно хватить.

Сделаем в методе main цикл for в котором будут создаваться объекты User на которые не ссылаются переменные.

public static void main(String[] args) {
     for (int i = 0; i < 13107; i++) {
         System.out.println(i);
         System.out.println(new User("Name"));
     }
}

Запустим программу:

2192
User{name='Name'}
2193
finalize
finalize

Сборщик мусора начал запускать метод finalize после создания 2192 объекта User, тем самым начав
очистку памяти от неиспользуемых объектов (на которые не ссылаются переменные).